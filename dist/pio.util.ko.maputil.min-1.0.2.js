/*! PIO.util.ko.maputil - v1.0.2 - 2013-12-10
* https://github.com/micahasmith/ko.mapUtil
* Copyright (c) 2013 Micah Smith; Licensed MIT */
var PIO=PIO||{};PIO.util=PIO.util||{},PIO.util.ko=PIO.util.ko||{},PIO.util.ko.mapUtil=function(o,n){var e=function(){var e=this,r=function(o,e){return o&&n.contains(o,e)?!0:!1},i=function(e){return o.isObservable(e)&&n.isArray(e())},s=function(o){return n.isString(o)||n.isDate(o)||n.isNumber(o)||n.isRegExp(o)||n.isBoolean(o)&&!n.isObject(o)},l=function(o){var n=o.source;return s(n)?n:e.build(o)},t=function(r){var s=r.source,t=r.destination,a=r.options||{},u=a.matchPredicate,c=(a.recurse||!0,a.ignore,Boolean(u)),b=[],g=[];return console.group("mapMany(): entered on,",r),t||(t=[]),i(t)||(console.log("mapMany(): making an observableArray of ",t),t=o.observableArray(t)),s&&i(s)&&(s=o.utils.unwrapObservable(s)),console.log("mapMany(): source is ",s),c||(console.log("mapMany(): no items, clearing observableArray of ",t),t.removeAll()),t().length?n.forEach(s,function(o){console.log("mapMany(): working on new item",o);var r=l({source:o,options:a.items||{}}),i=n(t()).find(function(o){return u(o,r)});i?e.map({source:r,destination:i,options:a.items||{}}):b.push(r)}):n(s).forEach(function(o){console.log("mapMany(): working on new item",o);var n=l({source:o,options:a.items||{}});b.push(n)}),console.log("mapMany(): addIn is ",b),g=t().concat(b),t(g),console.log("mapMany(): returning ",t),console.groupEnd(),t};this.build=function(i){var s=i.destination||{},l=i.source,t=i.options||{},a=t.recurse||!0,u=t.ignore,c=t.preBuild,b=t.postBuild;if(console.group("build(): entered on ",i),Boolean(l.__kom))return l;if(c&&(console.log("build(): calling prebuild"),s=c(s),!s))throw Error("prebuild function did not return a value");if(n.forEach(l,function(i,l){return console.log("build(): working on ",l,i),r(u,l)?(console.log("build(): ignoring ",l),void 0):(n.isFunction(i)&&o.isWriteableObservable(i)?(console.log("build(): a function",l),s[l]=i):n.isArray(i)?0===i.length?s[l]=o.observableArray([]):a&&(n.isObject(i[0])||n.isPlainObject(i[0]))?(console.log("build(): recursing into array items under ",l),s[l]=o.observableArray(n.map(i,function(o){return e.build({source:o,options:t[l]||{}})}))):(console.log("build(): assigning ",l," value ",i),s[l]=o.observableArray(i)):n.isPlainObject(i)||n.isObject(i)?(console.log("build(): is object ",l),s[l]=a?e.build({source:i,options:t[l]||{}}):o.observable(i)):(console.log("build(): is primitive ",l),s[l]=o.observable(i)),void 0)}),s.__kom=!0,s.__komId=Math.random(),b&&(console.log("build(): calling postbuild"),s=b(s),!s))throw Error("postbuild function did not return a value");return console.log("build():returning ",s),console.groupEnd(),s},this.map=function(s){var l=s.source,a=s.destination,u=s.options||{},c=function(){return e.build({source:l,options:u})},b=u.recurse||!0,g=u.ignore||[],p={};return console.group("map(): entered on ",s),g&&g.push("__kom"),n.isArray(l)||i(l)?(console.log("is an array/observableArray"),p=t(s),console.groupEnd(),p):a?(n.has(l,"__kom")||(console.log("map(): doing a prebuild on ",l),l=c()),n.forEach(l,function(s,c){if(console.group("map(): working on ",c),console.log("map(): value is ",c,s),n.has(a,c)&&!r(g,c)){var p,d,m=function(o){return o()},f=function(o,n){o(n)};i(s)?(console.log("map(): item is observableArray, calling mapMany on ",c),t({source:s,destination:a[c],options:u[c]||{}})):n.isFunction(s)?o.isWriteableObservable(s)&&(console.log("map(): item is observable",c),p=m,d=f):n.isObject(s)&&b&&(console.log("map(): is object, recursing on ",c),e.map(n.defaults({source:s,destination:a[c]},{options:u[c]||{}}))),Boolean(p)&&Boolean(d)&&(console.log("setting one to another"),d(a[c],p(l[c]))),console.groupEnd()}}),console.log("map(): returning ",a),console.groupEnd(),a):(console.log("map(): just a build request"),p=c(),console.groupEnd(),p)}};return new e}(ko,_);